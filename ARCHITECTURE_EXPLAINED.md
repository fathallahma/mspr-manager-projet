# üèóÔ∏è Explication de l'Architecture du Projet MSPR COFRAP

Bienvenue dans ce document ! Son objectif est de d√©mystifier l'architecture de notre projet, de vous expliquer le r√¥le de chaque technologie et de vous montrer comment toutes ces briques s'assemblent pour fonctionner.

## üè¢ Vue d'Ensemble : L'Analogie de l'Immeuble High-Tech

Pour commencer, imaginons que notre projet est un **immeuble d'appartements high-tech** que nous construisons. Cette image nous aidera √† comprendre le r√¥le de chaque composant principal.

-   **k3d (Kubernetes)** : C'est le **terrain, les fondations et la structure** de l'immeuble. Il fournit l'environnement robuste et professionnel sur lequel nous allons construire.
-   **OpenFaaS (Serverless)** : C'est l'**agence de gestion de l'immeuble**. Elle s'occupe de transformer notre logique m√©tier (notre code) en appartements fonctionnels (des API web) et g√®re l'acc√®s √† ces appartements.
-   **PostgreSQL** : C'est le **grand fichier central des r√©sidents**. C'est la m√©moire √† long terme de notre immeuble, qui stocke de mani√®re s√©curis√©e qui a le droit d'entrer, les cl√©s des appartements, etc.

---

## üß± Brique par Brique : Explications D√©taill√©es

Maintenant, plongeons dans le d√©tail de chaque technologie. Pour continuer notre fil rouge, nous utiliserons une autre analogie : celle d'un **restaurant de pizzas moderne**.

### 1. k3d : Le Local Commercial du Restaurant

**Qu'est-ce que c'est ?**
**k3d**, c'est "Kubernetes in Docker". Kubernetes est un syst√®me de niveau industriel (utilis√© par Google, Netflix...) pour g√©rer des milliers de conteneurs. Il est extr√™mement puissant, mais aussi tr√®s lourd √† installer sur un simple PC. k3d est une version **l√©g√®re et simplifi√©e** de Kubernetes, con√ßue pour les d√©veloppeurs. Il nous permet de faire tourner un "mini-cloud" sur notre machine.

**Son r√¥le dans notre projet :**
-   **Le Terrain Vierge** : k3d nous fournit un "local commercial" vide. Il pr√©pare les fondations, l'√©lectricit√©, l'eau (le r√©seau, le stockage, la puissance de calcul).
-   **L'Orchestrateur Fiable** : C'est le propri√©taire du local. Il s'assure que tout est solide. Si un conteneur "tombe en panne", Kubernetes le red√©marre automatiquement, garantissant une haute disponibilit√©.

> **En r√©sum√©** : k3d ne fait pas tourner notre code Python directement. Il **construit et g√®re la cuisine professionnelle** dans laquelle notre chef (OpenFaaS) va pouvoir travailler.

---

### 2. OpenFaaS : Le Manager et le Chef de Cuisine

**Qu'est-ce que c'est ?**
**OpenFaaS** (Functions as a Service) est une plateforme "Serverless". L'id√©e du serverless n'est pas qu'il n'y a pas de serveurs, mais que **nous, les d√©veloppeurs, n'avons pas √† nous en soucier**. Nous √©crivons une simple fonction, et OpenFaaS s'occupe de tout le reste.

**Son r√¥le dans notre projet :**
-   **Le Chef de Cuisine** : Il prend nos "recettes" (nos fonctions Python `generate-password`, `authenticate-user`...) et les transforme en plats pr√™ts √† servir (des API web s√©curis√©es).
-   **Le Manager √† l'Accueil** : Le composant "Gateway" d'OpenFaaS est le manager du restaurant. Il se place √† l'entr√©e, prend les commandes des clients (les requ√™tes du frontend React) et les transmet au bon cuisinier.
-   **Gestionnaire Efficace** : Si personne ne commande une certaine pizza, le chef n'allume pas le four correspondant (la fonction est en "veille"). Si 1000 personnes commandent la m√™me pizza, le chef met 10 cuisiniers sur le coup (OpenFaaS "scale" la fonction automatiquement).
-   **Il s'appuie sur k3d** : Pour chaque "cuisinier", OpenFaaS demande √† k3d de lui fournir un poste de travail (un conteneur).

> **En r√©sum√©** : OpenFaaS est le **cerveau op√©rationnel** de notre restaurant. Il prend nos recettes (le code) et utilise la cuisine (k3d) pour servir les clients.

---

### 3. PostgreSQL : Le Grand Garde-Manger S√©curis√©

**Qu'est-ce que c'est ?**
PostgreSQL est une base de donn√©es relationnelle. C'est un syst√®me de stockage de donn√©es ultra-fiable, structur√© et s√©curis√©.

**Son r√¥le dans notre projet :**
-   **La M√©moire √† Long Terme** : Un chef (une fonction serverless) a une m√©moire √† court terme. Une fois la pizza servie, il oublie la commande. On dit qu'il est "stateless" (sans √©tat).
-   **Le Garde-Manger** : PostgreSQL est le grand garde-manger o√π l'on stocke durablement toutes les informations vitales : la liste des clients (`users`), leurs recettes secr√®tes (mots de passe hach√©s), leurs cartes de fid√©lit√© (secrets 2FA), etc.
-   **La Source de V√©rit√©** : Quand un client revient, c'est en consultant le garde-manger que le restaurant peut le reconna√Ætre.

> **En r√©sum√©** : PostgreSQL est le **gardien des donn√©es critiques**. Sans lui, notre service serait amn√©sique et inutile.

---

## üåâ Le Pont Magique : Comment k3d Parle √† la Base de Donn√©es Locale

C'est l'un des points les plus techniques et importants √† comprendre. Comment nos fonctions, qui vivent dans le "mini-cloud" k3d, peuvent-elles parler √† notre base de donn√©es, qui vit directement sur notre PC ?

La connexion est possible gr√¢ce √† un "pont" construit sur 3 piliers :

```mermaid
graph TD
    subgraph "Votre Machine (H√¥te)"
        A["<b>PostgreSQL</b><br/>(L'entrep√¥t)<br/>Install√© sur votre OS"]
    end

    subgraph "R√©seau Docker"
        B["<b>host.k3d.internal</b><br/>Un 'panneau indicateur' qui dit :<br/>'La sortie vers la machine h√¥te, c'est par ici !'"]
    end
    
    subgraph "Cluster k3d (La Cuisine)"
        C["Fonction Python<br/>(Le Chef)"]
    end
    
    C -- "1. La fonction appelle l'adresse 'host.k3d.internal'" --> B
    B -- "2. k3d traduit ce nom en l'adresse IP de votre machine" --> A
```

1.  **L'Adresse Sp√©ciale (`host.k3d.internal`)**
    -   Quand une fonction s'ex√©cute dans un conteneur k3d, elle est isol√©e. Pour lui permettre de "sortir" et de parler √† la machine qui l'h√©berge, k3d cr√©e un nom de domaine magique : `host.k3d.internal`. C'est l'adresse que nous avons mise dans `stack.yaml` (`DB_HOST`).

2.  **La Porte Ouverte (`listen_addresses = '*'`)**
    -   Par d√©faut, PostgreSQL est parano√Øaque et n'√©coute que les appels venant de lui-m√™me (`localhost`). En changeant ce param√®tre pour `*`, on lui dit d'ouvrir grand ses portes et d'accepter les connexions qui viennent de n'importe o√π, y compris du pont k3d.

3.  **Le Gardien √† l'Entr√©e (`pg_hba.conf`)**
    -   M√™me si la porte est ouverte, un gardien v√©rifie les identit√©s. En ajoutant la ligne `host all all 0.0.0.0/0 md5`, nous donnons au gardien la consigne suivante : "Laisse entrer n'importe qui (`0.0.0.0/0`), √† condition qu'il te donne le bon mot de passe (`md5`)."

C'est cette combinaison qui rend la communication possible et s√©curis√©e.

---

## ü§î Choix d'Architecture : Pourquoi une Base de Donn√©es Locale ?

Une question l√©gitime est : "Pourquoi ne pas mettre aussi la base de donn√©es dans un conteneur Docker ?"

**R√©ponse courte : Pour la simplicit√© et la rapidit√© du d√©veloppement dans le cadre de ce MSPR.**

-   **Votre approche (DB locale)** est comme construire une **maquette d'architecture**. Vous utilisez les outils sur votre bureau pour √™tre rapide et efficace. C'est parfait pour d√©montrer le concept.
-   **L'approche "Production" (DB en conteneur)** est comme construire le **vrai b√¢timent**. Chaque pi√®ce est standardis√©e (conteneuris√©e) pour √™tre robuste et reproductible.

Pour ce projet, o√π l'accent est mis sur l'architecture **serverless et s√©curis√©e**, utiliser une base de donn√©es locale est un choix pragmatique et intelligent. Il nous a permis de nous concentrer sur le c≈ìur du sujet sans ajouter la complexit√© de la gestion d'un conteneur de base de donn√©es.

Nous esp√©rons que ce document vous aidera √† mieux comprendre les rouages de ce projet passionnant !

---

## ‚öôÔ∏è Le Backend : Comment √ßa Marche Sans Flask ni Django ?

Une question tr√®s importante se pose : quel framework web Python utilisons-nous pour le backend ? Flask ? Django ? FastAPI ?

La r√©ponse est : **aucun d'entre eux**. Notre backend ne ressemble pas √† une application web traditionnelle. Il est enti√®rement b√¢ti sur le mod√®le "Functions as a Service" fourni par OpenFaaS.

### La Diff√©rence Fondamentale avec un Framework Classique

Dans une application classique avec Flask, **vous** √™tes responsable de cr√©er et de g√©rer le serveur web :
```python
# Exemple avec Flask - CE QUE NOUS NE FAISONS PAS
from flask import Flask, request

app = Flask(__name__) # Vous cr√©ez l'application

@app.route('/generate-password', methods=['POST']) # Vous d√©finissez les routes
def generate_password_route():
    # Votre logique ici
    return {"password": "..."}

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000) # Vous lancez le serveur
```

Dans notre projet, tout ce code "d'infrastructure" (cr√©er l'application, d√©finir les routes, lancer le serveur) **n'existe pas**. Il est enti√®rement pris en charge par la plateforme **OpenFaaS**.

### Le R√¥le du Template `python3-http`

Le secret de notre architecture backend r√©side dans la ligne `lang: python3-http` de notre fichier `stack.yaml`. En choisissant ce "template", nous demandons √† OpenFaaS de faire le travail suivant pour nous :

1.  **Cr√©er un Mini-Serveur Web** : Pour chaque fonction, OpenFaaS construit une image Docker contenant Python et un tout petit serveur web ultra-l√©ger et optimis√©.
2.  **G√©rer le Point d'Entr√©e** : Ce serveur est pr√©-programm√© pour faire une seule chose : recevoir une requ√™te HTTP, et la passer √† une fonction unique nomm√©e `handler` qui doit se trouver dans un fichier `handler.py`.
3.  **Simplifier notre Travail** : Notre seul r√¥le en tant que d√©veloppeur backend est donc d'√©crire la logique m√©tier pure √† l'int√©rieur de cette fonction `handler`.

Voici √† quoi ressemble notre code :
```python
# generate-password/handler.py

# On importe les objets Request et Response fournis par le template OpenFaaS
from faas_http import Request, Response
import json
# ... autres imports ...

# Voici notre SEUL point d'entr√©e. C'est tout notre "backend".
def handler(req: Request) -> Response:
    """
    Traite une requ√™te vers la fonction.
    """
    try:
        # 1. On r√©cup√®re le corps de la requ√™te
        body = req.get_json()
        username = body.get("username")

        # ... toute notre logique ...

        # 2. On pr√©pare une r√©ponse
        response_data = {"success": True, "password": "a-new-password"}
        
        # 3. On retourne un objet Response avec le statut 200 (OK)
        return Response(json.dumps(response_data), status_code=200)

    except Exception as e:
        # En cas d'erreur, on retourne un objet Response avec le statut 500
        return Response(json.dumps({"success": False, "error": str(e)}), status_code=500)
```

**Ce qui est remarquable, c'est ce qui est absent :**
-   Aucune cr√©ation d'application (`app = Flask(...)`).
-   Aucune d√©finition de route (`@app.route(...)`).
-   Aucun lancement de serveur (`app.run()`).

Nous nous concentrons uniquement sur la logique m√©tier, et OpenFaaS g√®re toute la complexit√© du serveur web.

### L'Analogie de la Cuisine "Fant√¥me" (Ghost Kitchen)

Pour bien visualiser la diff√©rence, voici l'analogie la plus proche :

-   **Une application Flask/Django** : C'est comme √™tre un chef qui ouvre son **propre food truck**. Vous devez acheter le camion (le serveur), choisir o√π vous garer (d√©finir les routes), g√©rer le moteur et l'essence (lancer et maintenir le processus serveur), ET cuisiner.

-   **Une fonction OpenFaaS** : C'est comme √™tre un chef qui travaille pour une **cuisine "fant√¥me" ultra-moderne** (une "ghost kitchen").
    -   Le propri√©taire de la cuisine (OpenFaaS) vous fournit un poste de travail parfaitement √©quip√© et standardis√©.
    -   Vous ne vous souciez ni des murs, ni de l'√©lectricit√©, ni de la plomberie.
    -   Un √©cran devant vous affiche une commande (l'objet `Request`).
    -   Votre unique travail est de **pr√©parer le plat** en suivant la commande (votre logique dans la fonction `handler`).
    -   Une fois le plat pr√™t, vous le posez sur le comptoir (vous retournez un objet `Response`), et un livreur (le Gateway OpenFaaS) s'occupe de l'amener au client. Vous √™tes imm√©diatement pr√™t pour la prochaine commande.

**En conclusion :** Le backend de notre projet n'est pas une application monolithique. C'est une **collection de micro-fonctions ind√©pendantes**, o√π toute la complexit√© du "serveur web" est abstraite par la plateforme OpenFaaS. C'est la puissance et l'√©l√©gance du mod√®le "Functions as a Service". 



Installer kubeseal (CLI) ‚Äì une fois
wget https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.23.1/kubeseal-0.23.1-linux-amd64.tar.gz
tar -xzf kubeseal-0.23.1-linux-amd64.tar.gz
sudo mv kubeseal /usr/local/bin/
kubeseal --version # v√©rification
Installer le contr√¥leur Sealed-Secrets dans le cluster ‚Äì une fois
kubectl apply -f https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.23.1/controller.yaml
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 2. Cr√©ation & scellement des secrets ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
G√©n√©rer la cl√© AES-256 pour 2FA
export MFA_KEY_B64=$(openssl rand -base64 32)
Sceller le mot de passe DB
kubectl create secret generic db-creds \
--namespace openfaas-fn \
--from-literal=DB_PASSWORD=mspr_password \
--dry-run=client -o yaml | \
kubeseal --namespace openfaas-fn --format yaml > sealed-db-creds.yaml
Sceller la cl√© 2FA
kubectl create secret generic mfa-key \
--namespace openfaas-fn \
--from-literal=MFA_KEY_B64=$MFA_KEY_B64 \
--dry-run=client -o yaml | \
kubeseal --namespace openfaas-fn --format yaml > sealed-mfa-key.yaml
Appliquer dans le cluster
kubectl apply -f sealed-db-creds.yaml
kubectl apply -f sealed-mfa-key.yaml
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 3. Lancement / relance quotidienne ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
./start_full_demo.sh # script principal (build, deploy, frontend)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 4. Commandes de maintenance utiles ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
V√©rifier l‚Äô√©tat des fonctions
faas-cli list --gateway http://127.0.0.1:8088